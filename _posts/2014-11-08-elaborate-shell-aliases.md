---
layout: post
publication: "published"
title: "Setting up quick access to current class assignments in the shell"
attentionconservationnotice: words on creating elaborate shell aliases with Unix text processing utilities (and with Ruby).
---

## The task at hand
The continuous inflow of assignments at gSchool demands to be corralled into some sort of order. I use numbered weekly directories, like so:

{% highlight bash %}
/Users/kevin
├── gschool
│   ├── notes
│   ├── projects
│   ├── w01
│   ├── w02
│   ├── w03
│   ├── w04
│   ├── w05
│   └── zxcvtest
{% endhighlight %}

Such an organizational schema immediately presents us with the task of aliasing a command to `cd` into the current week's directory. That should be the one with the highest alphanumeric value in the `gschool` directory whose name matches the pattern "w"-digit-digit. So if we list all such folders in alphanumeric order and grab the last one, we'll have the one we want.

I implemented a solution along those lines first with Unix text processing utilities, and then, as an experiment, with Ruby.


## A solution with `grep` and `tail`
Here's what my alias ended up looking like; I'll explain each component below.

{% highlight bash %}
alias gs="cd $HOME/gschool/$(ls $HOME/gschool | egrep 'w\d\d' | tail -1)"
{% endhighlight %}

`$()` evaluates the expression inside the parentheses before evaluating the expression to which it belongs.

`ls $HOME/gschool` prints the contents of the `gschool` directory to stdout in Unix alphanumeric order. Note that Unix alphanumeric order is based on the sequential evaluation of the values of single characters, so `w11` would come before `w2`. When naming the weekly directories, we therefore need to pad single-digit weeks with zeroes to preserve true numerical order. (The order becomes important once we get to the `sed` command.)

`egrep 'w\d\d'` takes the list generated by `ls` and winnows it down to only those directories that match the pattern "w"-digit-digit (provided as the regular expression `/w\d\d/`), ensuring that any other subdirectories of `gschool` are ignored. The cleaned-up list is printed to stdout.

Finally, `tail -1` prints the last line of `egrep`'s output to stdout.  [`tail`](http://en.wikipedia.org/wiki/Tail_%28Unix%29) (partner-in-crime of [`head`](http://en.wikipedia.org/wiki/Head_%28Unix%29)) is a Unix utility that prints out the ends of files or streams. Because, as discussed above, the output of `ls` was in alphanumeric order, and `grep` preserved that order, this will be the directory whose name has the highest alphanumeric value. We've got the current week's directory!

#### Or, less legibly than `tail -1`...
Before I discovered the existence of `tail` in the course of writing this post, I had been using `sed -n '$p'` to print the last line of the stream from `grep`. For anyone interested, here's how that little snippet works.

Sed, a so-called "non-interactive text editor," reads text one line at a time, copying each line into "pattern space" to evaluate whether it matches the "address" provided to it and whether Sed should therefore execute the provided "command" on it. Sed's default behavior is next to print the line in pattern space to stdout before moving onto the next line. We don't want that, because we only want the last line of the stream to be printed out; the `-n` flag suppresses that default behavior. The `$` in `'$p'` is the Sed address, and refers to the last line of the file or stream; `p` is the command, and means print. `'$p'` must be quoted because besides its meaning in Sed, `$` is also a shell metacharacter, and if not quoted would be interpreted by the shell rather than by Sed.


## Using Ruby instead of `grep` and `tail`
Inspired by [this excellent blog post](https://robm.me.uk/ruby/2013/11/20/ruby-enp.html), I decided to try rewriting the alias using Ruby instead of `grep` and `tail`. Here's what I came up with:

{% highlight bash %}
# The Ruby code that replaces grep and tail (i.e., takes the output of an `ls` of the `gschool` directory and prints the current week's folder):

ruby -ne 'BEGIN{ary = []}; ary.push($_) if $_.match(/w\d\d/); END{puts ary[-1]}'

# The full alias:

alias gs="cd $GS/$(ls $HOME/gschool | ruby -ne 'BEGIN{ary = []}; ary.push($_) if $_.match(/w\d\d/); END{puts ary[-1]}')"
{% endhighlight %}

Let's break that down. The `-e` flag simply tells Ruby to execute the quoted code. The `-n` flag tells Ruby to iterate over each line of input, and makes each line available via the `$_` variable. So the Ruby code is a loop—but the [`BEGIN`](http://ruby-doc.org/docs/keywords/1.9/#M000009) and [`END`](http://ruby-doc.org/docs/keywords/1.9/#M000009) blocks execute before and after the iteration, so only the middle statement actually loops.

Step by step, then:

1. `BEGIN{ary = []}` creates an empty array before the start of the iteration.
2. `ary.push($_) if $_.match(/w\d\d/)` iterates over each line that was output by `ls`, adding it to the array when it matches the pattern "w"-digit-digit ().
3. Finally, after the iteration completes, `END{puts ary[-1]}` prints the last item in the array to stdout.


## Conclusion
There may be a more elegant way to have done that in Ruby, but for now, looks like a win for Unix text processing utilities on both the concision and the legibility fronts.
